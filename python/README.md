# Acc32 Forth. Транслятор и модель процессора

<!-- markdown-toc start - Don't edit this section. Run M-x markdown-toc-refresh-toc -->
**Table of Contents**

- [Brainfuck. Транслятор и модель](#brainfuck-транслятор-и-модель)
    - [Язык программирования](#язык-программирования)
    - [Язык программирования Asm](#язык-программирования-asm)
    - [Организация памяти](#организация-памяти)
    - [Система команд](#система-команд)
        - [Набор инструкций](#набор-инструкций)
        - [Кодирование инструкций](#кодирование-инструкций)
            - [Бинарное представление](#бинарное-представление)
            - [JSON представление](#json-представление)
    - [Транслятор](#транслятор)
    - [Модель процессора](#модель-процессора)
        - [DataPath](#datapath)
        - [ControlUnit](#controlunit)
    - [Тестирование](#тестирование)
- [Footnotes](#footnotes)

<!-- markdown-toc end -->

---

- `forth | acc | neum | mc | tick | binary | stream | mem | cstr | prob2 | superscalar`

## Язык программирования

### Синтаксис

``` ebnf
program ::= terms

terms ::= term
        | term terms

term ::= word
       | number
       | string
       | comment
       | ":" terms ";"
       | "IF" terms "ELSE" terms "THEN"
       | "BEGIN" terms "WHILE" terms "REPEAT"

word ::= <последовательность печатных символов, кроме пробелов>

number ::= <целое число>

string ::= S" <любые символы>"

comment ::= # <любые символы до конца строки>
```

### Семантика
- Стратегия вычислений - стековая.
- Постфиксная запись (обратная польская нотация).
- Стек данных и аккумулятор — основные механизмы передачи аргументов между функциями.
- Стек возвратов — хранит адреса возврата для управления потоком выполнения.
- Сначала код компилируется, потом выполняется.
- Область видимости: все переменные и все функции доступны везде, с условием, что переменные и функции объявлены до исполняемого кода.
- Типизация слабая. Термом S" <последовательность_символов>" объявляются строки, любое число определяется как знаковое. Строки, записанные не в указанном формате, трактуются как названия переменных или функций. Число может быть записано в десятичном или шестнадцатиричном формате. 

Код выполняется последовательно.

## Организация памяти

Модель памяти процессора:

Память команд и данных общая (архитектура фон Неймана). Память разделена на разделы:
- функции (если они есть);
- исполняемый код;
- сохраненные переменные - статические данные;
- стек данных (растет "вверх") - динамические данные;
- стек возврата (растет "вниз" от последней ячейки памяти).

Регистры:
- PC -- program counter. Хранит указатель на ячейку с исполняемой командой. 3 байта.
- CR -- command register. Хранит исполняемую команду. 4 байта.
- IR -- instruction register. Хранит опкод исполняемой команды. 1 байт.
- BR -- buffer register. Хранит аргумент исполняемой команды. 3 байта.
- AC -- accumulator. Регистр общего назначения, из него записываются данные в память.
- DR -- data register. Хранит либо второй операнд для операции, либо адрес, по которому нужно сохранить значение из AC.
- AR -- address register. Хранит либо указатель на один из стеков, либо адрес из AC/DR.
- DSP -- data stack pointer. Хранит указатель на последнюю заполненную ячейку стека данных.
- RSP -- return stack pointer. Хранит указатель на последнюю заполненную ячейку стека возврата.
- DA -- data address. Хранит адрес, по которому мы обращаемся в память (либо из PC, либо из AR).
- mPC -- micro program counter. Хранит указатель на ячейку с исполняемой микрокомандой.

Размер машинного слова - 32 бита. Адресация только прямая, но с помощью последовательного применения команды LOAD можно добиться косвенной.

Понятия константы не существует, любую переменную можно изменить. Каждому литералу (символу) отведена целая ячейка памяти в 32 бита. Если данные (число или строка) требуют больше, чем 1 машинного слова, они размещаются по порядку в двух и более ячейках. Литерал нельзя положить на стек данных, его можно сохранить только в статическую память.
Функции хранятся там же, где и основной код, но обязательно в начале кода. После трансляции в термы, транслятор определяет адрес команды, идущей за последней командой RETURN, и записывает этот адрес в ячейку памяти под номером 0x4 (она же является memory mapped output). Таким образом, процессор понимает, откуда начинать выполнение.

## Система команд

### Особенности процессора:

- Доступ к памяти данных осуществляется по адресу, хранящемуся в специальном регистре `Data address`. Установка адреса осуществляется несколькими путями: инкрементом, прибавлением 4 или адресом перехода. Прибавление 1 или 4 происходит в зависимости от длины инструкции и управляется из микрокода.
- Обработка данных осуществляется по текущему адресу. Процессор считывает 4 байта из памяти. Даже если текущая инструкция занимает 1 байт, мы никогда не выйдем за пределы памяти, потому что на два стека отведено как минимум 8 байт. Таким образом, ненужные байты заполнятся в регистре CR "мусорными" значениями.
- Из CR опкод попадает в IR, а далее в дешифратор инструкций, где определяется команда и выполняются соответствующие микрокоманды. Дешифратор адреса - таблица, где каждой команде сопоставлен адрес первой микрокоманды. На адресах 0-4 лежат микрокоманды цикла выборки команды, которые запускаются в начале каждой новой инструкции.
- Поток управления:
    - инкремент или увеличение на 4 `PC` после каждой инструкции;
    - условный (`IF`, `WHILE`) и безусловный (`ELSE`, `REPEAT`) переходы.
- Адресация везде прямая.
- Поток ввода-вывода осуществляется через Memory-Mapped IO. 0x0 - ячейка ввода, 0x4 - ячейка вывода.

### Набор инструкций

Существует три типа команд: с аргументом, без аргумента и те, которые не транслируются. Опкод занимает 1 байт, аргумент 3 байта.

Команды с аргументом:
- `LOAD_IMM` -- загружает в аккумулятор число или адрес переменной и кладет его на стек. Синтаксис: "42" или "<имя переменной>". Аргумент: число или адрес переменной.
- `IF` -- команда ветвления. Проверяет значение в аккумуляторе: если -1, выполняет код после IF, если 0, выполняет код после ELSE. Аргумент: адрес первой инструкции после ELSE.
- `ELSE` -- перекидывает выполнение на код после THEN (если мы дошли до ELSE, значит IF было выполнено). Аргумент: адрес первой инструкции после THEN.
- `WHILE` -- команда цикла. Проверяет значение в аккумуляторе: если -1, выполняет код после WHILE, если 0, выполняет код после REPEAT. Аргумент: адрес первой инструкции после REPEAT.
- `REPEAT` -- перекидывает выполнение на код после BEGIN. Аргумент: адрес первой инструкции после BEGIN.


Команды без аргумента:
- `LOAD` -- загружает в аккумулятор значение по адресу в аккумуляторе и кладет его на вершину стека.
- `SAVE` -- сохраняет значение аккумулятора по адресу с вершины стека.
- `POP_AC` -- снимает значение с вершины стека и кладет в аккумулятор.
- `POP_DR` -- снимает значение с вершины стека и кладет в регистр DR.
- `PLUS` -- складывает значение аккумулятора и значение с вершины стека, результат кладет на стек.
- `MINUS` -- находит разницу между значением аккумулятора и значением с вершины стека, результат кладет на стек.
- `MULT` -- умножает значение аккумулятора и значение с вершины стека, результат кладет на стек.
- `DIV` -- делит значение аккумулятора на значение с вершины стека, результат кладет на стек.
- `MOD` -- делит по модулю значение аккумулятора на значением с вершины стека, результат кладет на стек.
- `AND` -- находит логическое И между значением аккумулятора и значением с вершины стека, результат кладет на стек.
- `OR` -- находит логическое ИЛИ между значением аккумулятора и значением с вершины стека, результат кладет на стек.
- `NOT` -- находит логическое НЕ значения аккумулятора, результат кладет на стек.
- `EQUAL` -- проверяет на равенство значение аккумулятора и значение с вершины стека, результат кладет на стек (-1 - равны, 0 - неравны).
- `LESS` -- проверяет, что значение аккумулятора меньше (знаково), чем значение с вершины стека, результат кладет на стек (-1 - меньше, 0 - не меньше).
- `GREATER` -- проверяет, что значение аккумулятора больше (знаково), чем значение с вершины стека, результат кладет на стек (-1 - больше, 0 - не больше).
- `HALT` -- команда останов.


Команды, которые не транслируются:
- `VARIABLE` -- определяет переменную (добавляет переменную в словарь переменных).
- `DEFINE_FUNC` -- определяет функцию (добавляет функцию в словарь переменных).
- `THEN` -- служит меткой конца кода ELSE.
- `BEGIN` -- служит меткой начала условия для WHILE.

### Кодирование инструкций

Типы данных в модуле [isa](./isa.py), где:

- `Opcode` -- перечисление кодов операций;
- `Term` -- структура для описания значимого фрагмента кода исходной программы.

#### Бинарное представление

Бинарное представление инструкций.

Команда с аргументом:
```text

    ┌─────────┬─────────────────────────────────────────────────────────────┐
    │ 31...24 │ 23                                                        0 │
    ├─────────┼─────────────────────────────────────────────────────────────┤
    │  опкод  │                      аргумент                               │
    └─────────┴─────────────────────────────────────────────────────────────┘
```


Команда без аргумента:
```text

    ┌─────────┐
    │  7...0  │ 
    ├─────────|
    │  опкод  │ 
    └─────────┘
```



Коды операций:

- LOAD: 0x2,  # 00000010
- PLUS: 0x4,  # 00000100
- MINUS: 0x6,  # 00000110
- MULT: 0x8,  # 00001000
- DIV: 0x10,  # 00001010
- MOD: 0x12,  # 00001100
- AND: 0x14,  # 00001110
- OR: 0x16,  # 00010000
- NOT: 0x18,  # 00010010
- EQUAL: 0x20,  # 00010100
- LESS: 0x22,  # 00010110
- GREATER: 0x24,  # 00011000
- HALT: 0x26,  # 00011010
- RETURN: 0x28,  # 00011100
- SAVE: 0x30,  # 00011110
- POP_AC: 0x32,  # 0100000
- POP_DR: 0x34,  # 0100010
- DUP: 0x36,  # 0100100
- LOAD_IMM: 0x3,  # 00000011
- CALL: 0x5,  # 00000101
- IF: 0x7,  # 00000111
- ELSE: 0x9,  # 00001001
- WHILE: 0x11,  # 00001011
- REPEAT: 0x13,  # 00001101

Микрокоманды (одна строка - один такт):
| address | command  | signal_if | latch_PC | MUX_PC(4) | latch_CR | latch_IR | latch_BR | MUX_ALU(4) | ALU(16) |
|---------|----------|-----------|----------|-----------|----------|----------|----------|------------|---------|
| 0       |          | 0         | 1        | 3         | 0        | 0        | 0        | 0          | 0       |
| 4       |          | 0         | 0        | 0         | 1        | 1        | 0        | 0          | 0       |
| 8       | LOAD_IMM | 0         | 1        | 1         | 0        | 0        | 1        | 2          | 0       |
| 12      | LOAD     | 0         | 1        | 2         | 0        | 0        | 0        | 0          | 0       |
| 16      |          | 0         | 0        | 0         | 1        | 0        | 0        | 3          | 0       |
| 20      |          | 0         | 0        | 0         | 0        | 0        | 0        | 0          | 0       |
| 24      | CALL     | 0         | 1        | 1         | 0        | 0        | 1        | 1          | 0       |
| 28      |          | 0         | 1        | 0         | 0        | 0        | 0        | 0          | 0       |
| 32 | RETURN | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 0 |
| 36 |        | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 40 |        | 0 | 0 | 0 | 1 | 0 | 1 | 0 | 0 |
| 44 |        | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 48 | SAVE   | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 0 |
| 52 | PLUS   | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 1 |
| 56 | MINUS  | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 2 |
| 60 | MULT    | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 3  |
| 64 | DIV     | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 4  |
| 68 | MOD     | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 5  |
| 72 | AND     | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 6  |
| 76 | OR      | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 7  |
| 80 | NOT     | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 8  |
| 84 | EQUAL   | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 9  |
| 88 | LESS    | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 10 |
| 92 | GREATER | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 11 |
| 96  | POP_AC | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 0 |
| 100 |        | 0 | 0 | 0 | 1 | 0 | 0 | 3 | 0 |
| 104 | POP_DR | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 0 |
| 108 |        | 0 | 0 | 0 | 1 | 0 | 0 | 3 | 0 |
| 112 | DUP    | 0 | 1 | 2 | 0 | 0 | 0 | 0 | 0 |
| 116 |        | 0 | 0 | 0 | 1 | 0 | 0 | 3 | 0 |
| 120 |        | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
| 124 | IF     | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 |
| 128 |        | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| 132 | ELSE   | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 |
| 136 |        | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 140 | WHILE  | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 |
| 144 |        | 1 | 1 | 1 | 0 | 0 | 0 | 0 | 0 |
| 148 | REPEAT | 0 | 0 | 0 | 0 | 0 | 1 | 0 | 0 |
| 152 |        | 0 | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
| 156 | HALT   | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 |

## Транслятор

Интерфейс командной строки: `translator.py <input_file> <target_file>`

Реализовано в модуле: [translator](./translator.py)

Этапы трансляции (функция `translate`):

1. Трансформирование текста в последовательность значимых термов.
2. Проверка корректности программы (парность квадратных скобок).
3. Удаление токенов, которые не отображаются напрямую в команды, создание таблицы линковки для названий функций и переменных.
4. Подстановка адресов вместо лейблов, вставка адресов переходов (в IF и WHILE)
5. Cохранение переменных после HALT.

Правила генерации машинного кода:
- встречаем число - команда LOAD_IMM.
- встречаем VARIABLE - удаляем предыдущую команду, потому что нам не нужен LOAD_IMM и сохраняем в две специальные таблицы, что нам нужно будет отобразить переменную в память.
- встречаем строку - это либо функция, либо переменная. Если ничего из этих вариантов - ошибка трансляции.
- встречаем команду, которой необходимы два аргумента - добавляем перед ней POP_AC + POP_DR (для SAVE наоборот, так как адрес лежит на стеке сверху).
- встречаем команду, которой необходим один аргумент - добавляем перед ней POP_AC.
- условный блок и блок с циклом обрабатываются по особому: при первом проходе в специальный словарь сохраняются адреса ELSE, THEN, BEGIN, REPEAT, а в команды IF, ELSE, WHILE вместо аргументов ставятся заглушки (-1). При втором проходе вместо заглушек подставляются адреса переходов.
- изменение адреса при каждой итерации тщательно управляется.

## Модель процессора

Интерфейс командной строки: ` machine.py <input_file> <memory_size> <mode> <eam>"`
input_file - адрес файла, выступающего входным буфером;
memory_size - размер памяти (для удобства конфигурации);
mode - режим отображения ответа (sym - символьный, dec - в десятичной сс, hex - в шестнадцатиричной cc);
eam - режим арифметики. 1 - расширенный, 0 - обычный.

Реализовано в модуле: [machine](./machine.py).

### DataPath



Реализован в классе `DataPath`.

`data_memory` -- однопортовая память, поэтому либо читаем, либо пишем.

Сигналы (обрабатываются за один такт, реализованы в виде методов класса):

signal_if							ALU(16)			(4)		(2)		(2)		oe	wr	mPC	(4)

Мультиплексоры: 
- MUX_PC -- 2 бита. 0 - значение из BR, 1 - PC+1, 2 - PC+4. Может выставляться с помощью сигнала signal_if (см. далее).
- MUX_ALU -- 2 бита. 0 - из DR, 1 - из PC, 2 - из BR, 3 - из CR.
- MUX_AR -- 2 бита. 0 - из AC, 1 - из RSP, 2 - из DSP, 3 - из DR.
- MUX_RSP -- 1 бит. 0 - RSP+4, 1 - RSP-4.
- MUX_DSP -- 1 бит. 0 - DSP+4, 1 - DSP-4.
- MUX_mPC -- 2 бита. 0 - 0, 1 - mpc+4, 1 - из instruction_decoder.
- MUX_MEM -- 1 бит. Идентичен сигналу latch_AR.

Сигналы защелкивания:
- latch_PC -- защелкивает значение PC, исходя из сигнала MUX_PC.
- latch_CR -- защелкивает значение CR. 
- latch_IR -- защелкивает значение IR.
- latch_BR -- защелкивает значение BR.
- latch_DR -- защелкивает значение DR.
- latch_AC -- защелкивает значение AC.
- latch_AR -- защелкивает значение AR, исходя из сигнала MUX_AR.
- latch_RSP -- защелкивает значение RSP, исходя из сигнала MUX_RSP.
- latch_DSP -- защелкивает значение DSP, исходя из сигнала MUX_DSP.
- mPC --  защелкивает значение mPC, исходя из сигнала MUX_mPC.

Сигнал для АЛУ:
- ALU -- сигнал команды для АЛУ. Пусть left - левый аргумент, right - правый. Тогда:
        if sel == 0:
            self.plus_zero(left)
        elif sel == 1:
            self.plus(right, left)
        elif sel == 2:
            self.minus(right, left)
        elif sel == 3:
            self.multiply(right, left)
        elif sel == 4:
            self.divide(right, left)
        elif sel == 5:
            self.modulo(right, left)
        elif sel == 6:
            self.logical_and(right, left)
        elif sel == 7:
            self.logical_or(right, left)
        elif sel == 8:
            self.logical_not(right)
        elif sel == 9:
            self.equal(right, left)
        elif sel == 10:
            self.less(right, left)
        elif sel == 11:
            self.greater(right, left)

Другие сигналы:
- oe -- output enable, разрешает чтение из памяти в CR по адресу из DA.
- wr -- write, разрешает запись в память из AC по адресу из DA.

Флаги:

- `zero` -- отражает наличие нулевого значения в аккумуляторе.

### ControlUnit

``` text
   ┌─────────────────(+1)───────┐
   │                             │
   │    latch_program_counter    │
   │                  │          │
   │   ┌─────┐        ▼          │
   └──►│     │     ┌─────────┐   │    ┌─────────┐
       │ MUX │────►│ program │───┴───►│ program │
   ┌──►│     │     │ counter │        │ memory  │
   │   └─────┘     └─────────┘        └─────────┘
   │      ▲                               │
   │      │ sel_next                      │ current instruction
   │      │                               │
   └──────────────(select-arg)────────────┘
          │                               │      ┌─────────┐
          │                               │      │  step   │
          │                               │  ┌───│ counter │
          │                               │  │   └─────────┘
          │                               ▼  ▼        ▲
          │                       ┌─────────────┐     │
          └───────────────────────│ instruction │─────┘
                                  │   decoder   │
                                  │             │◄───────┐
                                  └─────────────┘        │
                                          │              │
                                          │ signals      │
                                          ▼              │
                                    ┌──────────┐  zero   │
                                    │          │─────────┘
                                    │ DataPath │
                     input ─────────►          ├─────────► output
                                    └──────────┘
```

Реализован в классе `ControlUnit`.

- Hardwired (реализовано полностью на Python).
- Метод `process_next_tick` моделирует выполнение полного цикла инструкции (1-2 такта процессора).
- `step_counter` необходим для многотактовых инструкций;
    - в реализации класса `ControlUnit` отсутствует, т.к. неявно задан потоком управления.

Сигнал:

- `latch_program_counter` -- сигнал для обновления счётчика команд в ControlUnit.

Особенности работы модели:

- Цикл симуляции осуществляется в функции `simulation`.
- Шаг моделирования соответствует одной инструкции с выводом состояния в журнал.
- Для журнала состояний процессора используется стандартный модуль `logging`.
- Количество инструкций для моделирования лимитировано.
- Остановка моделирования осуществляется при:
    - превышении лимита количества выполняемых инструкций;
    - исключении `EOFError` -- если нет данных для чтения из порта ввода;
    - исключении `StopIteration` -- если выполнена инструкция `halt`.

## Тестирование

Тестирование выполняется при помощи golden test-ов.

1. Тесты для языка `bf` реализованы в: [golden_bf_test.py](./golden_bf_test.py). Конфигурации:
    - [golden/cat_bf.yml](golden/cat_bf.yml)
    - [golden/hello_bf.yml](golden/hello_bf.yml)
1. Тесты для языка `asm` реализованы в: [golden_asm_test.py](./golden_asm_test.py). Конфигурации:
    - [golden/cat_asm.yml](golden/cat_asm.yml)

Запустить тесты: `poetry run pytest . -v`

Обновить конфигурацию golden tests:  `poetry run pytest . -v --update-goldens`

Пример использования транслятора (бинарное и json представление машинного кода):

``` shell
$ cd brainfuck/python
$ cat examples/cat.bf
,[.,]
$ ./translator.py examples/cat.bf out/target.bin
source LoC: 2 code instr: 6
$ xxd out/target.bin
00000000: 5000 0000 7000 0005 4000 0000 5000 0000  P...p...@...P...
00000010: 6000 0001 8000 0000                      `.......
$ cat out/target.bin.hex
0 - 50000000 - input
1 - 70000005 - jz 5
2 - 40000000 - print
3 - 50000000 - input
4 - 60000001 - jmp 1
5 - 80000000 - halt⏎
$ ./translator.py examples/cat.bf out/target.json
source LoC: 2 code instr: 6
$ cat out/target.json
[{"index": 0, "opcode": "input", "term": [1, 1, ","]},
 {"index": 4, "opcode": "jz", "arg": 5, "term": [1, 2, "["]},
 {"index": 2, "opcode": "print", "term": [1, 3, "."]},
 {"index": 3, "opcode": "input", "term": [1, 4, ","]},
 {"index": 4, "opcode": "jmp", "arg": 1, "term": [1, 5, "]"]},
 {"index": 5, "opcode": "halt"}]⏎
```

Пример использования модели процессора:

``` shell
$ cat examples/foo_input.txt
foo
$ ./machine.py out/target.bin examples/foo_input.txt
DEBUG:root:TICK:   0 PC:   0/0 ADDR:   0 MEM_OUT: 0 ACC: 0 	input [50000000]
DEBUG:root:TICK:   1 PC:   0/1 ADDR:   0 MEM_OUT: 0 ACC: 0 	input [50000000]
DEBUG:root:input: 'f'
DEBUG:root:TICK:   2 PC:   1/0 ADDR:   0 MEM_OUT: 102 ACC: 0 	jz 5 [70000005]
DEBUG:root:TICK:   3 PC:   1/1 ADDR:   0 MEM_OUT: 102 ACC: 102 	jz 5 [70000005]
DEBUG:root:TICK:   4 PC:   2/0 ADDR:   0 MEM_OUT: 102 ACC: 102 	print [40000000]
DEBUG:root:TICK:   5 PC:   2/1 ADDR:   0 MEM_OUT: 102 ACC: 102 	print [40000000]
DEBUG:root:output: '' << 'f'
DEBUG:root:TICK:   6 PC:   3/0 ADDR:   0 MEM_OUT: 102 ACC: 102 	input [50000000]
DEBUG:root:TICK:   7 PC:   3/1 ADDR:   0 MEM_OUT: 102 ACC: 102 	input [50000000]
DEBUG:root:input: 'o'
DEBUG:root:TICK:   8 PC:   4/0 ADDR:   0 MEM_OUT: 111 ACC: 102 	jmp 1 [60000001]
DEBUG:root:TICK:   9 PC:   1/0 ADDR:   0 MEM_OUT: 111 ACC: 102 	jz 5 [70000005]
DEBUG:root:TICK:  10 PC:   1/1 ADDR:   0 MEM_OUT: 111 ACC: 111 	jz 5 [70000005]
DEBUG:root:TICK:  11 PC:   2/0 ADDR:   0 MEM_OUT: 111 ACC: 111 	print [40000000]
DEBUG:root:TICK:  12 PC:   2/1 ADDR:   0 MEM_OUT: 111 ACC: 111 	print [40000000]
DEBUG:root:output: 'f' << 'o'
DEBUG:root:TICK:  13 PC:   3/0 ADDR:   0 MEM_OUT: 111 ACC: 111 	input [50000000]
DEBUG:root:TICK:  14 PC:   3/1 ADDR:   0 MEM_OUT: 111 ACC: 111 	input [50000000]
DEBUG:root:input: 'o'
DEBUG:root:TICK:  15 PC:   4/0 ADDR:   0 MEM_OUT: 111 ACC: 111 	jmp 1 [60000001]
DEBUG:root:TICK:  16 PC:   1/0 ADDR:   0 MEM_OUT: 111 ACC: 111 	jz 5 [70000005]
DEBUG:root:TICK:  17 PC:   1/1 ADDR:   0 MEM_OUT: 111 ACC: 111 	jz 5 [70000005]
DEBUG:root:TICK:  18 PC:   2/0 ADDR:   0 MEM_OUT: 111 ACC: 111 	print [40000000]
DEBUG:root:TICK:  19 PC:   2/1 ADDR:   0 MEM_OUT: 111 ACC: 111 	print [40000000]
DEBUG:root:output: 'fo' << 'o'
DEBUG:root:TICK:  20 PC:   3/0 ADDR:   0 MEM_OUT: 111 ACC: 111 	input [50000000]
DEBUG:root:TICK:  21 PC:   3/1 ADDR:   0 MEM_OUT: 111 ACC: 111 	input [50000000]
DEBUG:root:input: '\n'
DEBUG:root:TICK:  22 PC:   4/0 ADDR:   0 MEM_OUT: 10 ACC: 111 	jmp 1 [60000001]
DEBUG:root:TICK:  23 PC:   1/0 ADDR:   0 MEM_OUT: 10 ACC: 111 	jz 5 [70000005]
DEBUG:root:TICK:  24 PC:   1/1 ADDR:   0 MEM_OUT: 10 ACC: 10 	jz 5 [70000005]
DEBUG:root:TICK:  25 PC:   2/0 ADDR:   0 MEM_OUT: 10 ACC: 10 	print [40000000]
DEBUG:root:TICK:  26 PC:   2/1 ADDR:   0 MEM_OUT: 10 ACC: 10 	print [40000000]
DEBUG:root:output: 'foo' << '\n'
DEBUG:root:TICK:  27 PC:   3/0 ADDR:   0 MEM_OUT: 10 ACC: 10 	input [50000000]
DEBUG:root:TICK:  28 PC:   3/1 ADDR:   0 MEM_OUT: 10 ACC: 10 	input [50000000]
WARNING:root:Input buffer is empty!
INFO:root:output_buffer: 'foo\n'
foo

ticks: 28
```
