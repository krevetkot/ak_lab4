   | 31 | 30 | 29 | 28 | 27 | 26 | 25 | 24 | 23 | 22 | 21 | 20 | 19 | 18 | 17 | 16 | 15 | 14 | 13 | 12 | 11 | 10 |  9 |  8 |  7 |  6 |  5 |  4 |  3 |  2 |  1 |  0 |
 1 |          opcode        ||||||
 2 |          opcode        |                                 immediate value / transition address                                                                 |




    тип 1 - команда без аргумента

    LOAD - загрузить по адресу переменной, который лежит в аккумуляторе. в операнде либо лейбл (тогда при линковке он заменится на адрес), либо сразу адрес
    @

    SKIP пока пусть будет

    PLUS = "+"
    MINUS = "-"
    MULT = "*"
    DIV = "/"
    MOD = "%"
    AND = "and"
    OR = "or"
    NOT = "not"
    EQUAL = "="
    LESS = "<"
    GREATER = ">"

    HALT = "halt"

    RETURN - ; (возвращается по последнему адресу из стека возврата)


   тип 3 - команды для транслятора. не переводятся в машинный код

    VARIABLE - создать переменную, к которой далее можно будет обращаться по имени. лейбл сохраняется в таблицу линковки. при трансляции вместо него подставится адрес
    0x80 VARIABLE input_addr 

    DEFINE_FUNC - определить функцию. оператор : 
     возврат из функции
    : "имя" код ;

   THEN - нужен для транслятора, чтобы узнать, куда прыгать после условия 
   BEGIN - метка, на которую мы будем возвращаться после repeat. никакой операции, только сохранение адреса в таблицу линковки 




    тип 2 - команда с аргументом

    LOAD_IMM - загрузить непосредственное значение. синтаксис - просто число.
    42

    LOAD_ADDR - загрузить по адресу @@ НЕ ИЗМЕНЯЕТ ДАТА РЕГИСТР

    SAVE - сохранить по адресу. команда записывается в ПРЯМОЙ нотации (пока что)
    ! address/label


    IF = "if" предлагаю всегда делать елз, даже если там ничего нет. аргумент иф - адрес начала елз
    ELSE = "else" - в едз хранится прыжок на зен



    WHILE - коп + адрес repeat 
    REPEAT - коп + адрес begin

